import os, strformat, base64, nimcrypto, nimcrypto/sysrand, zippy, terminal

func toByteSeq*(str: string): seq[byte] {.inline.} =
    # Converts a string to the corresponding byte sequence
    @(str.toOpenArrayByte(0, str.high))

# Function to prompt for user input
proc prompt(message: string): string =
  echo message
  result = readLine(stdin)

# Main function that processes the encryption
proc processEncryption() =
  let
    password = prompt("Enter the password:")
    inFile = prompt("Enter the path to the input file:")
    outFile = changeFileExt(inFile, ".lol")  # Change output file extension to .enc

  try:
    # Read and compress the input file content
    var inFileContents = compress(readFile(inFile), 9, dfGzip)
    var plaintext = toByteSeq(inFileContents)
    var ectx: CTR[aes256]
    var key: array[aes256.sizeKey, byte]
    var iv: array[aes256.sizeBlock, byte]
    var encrypted = newSeq[byte](len(plaintext))
    # echo fmt"plaintext:{plaintext}"
    # echo fmt"len plaintext:{len(plaintext)}"

    # Generate a static IV (consider using a random IV instead)
    iv = [byte 183, 142, 238, 156, 42, 43, 248, 100, 125, 249, 192, 254, 217, 222, 133, 149]

    # Derive a key using SHA-256 from the password
    var expandedKey = sha256.digest(password)
    copyMem(addr key[0], addr expandedKey.data[0], len(expandedKey.data))

    echo fmt"[*] Encrypting {inFile} using the provided password."

    # Initialize the encryption context and encrypt
    ectx.init(key, iv)
    ectx.encrypt(plaintext, encrypted)
    ectx.clear()

    # Base64 encode the encrypted data
    let encodedCrypted = encode(encrypted)

    echo fmt"[*] Writing encrypted base64 encoded data to: {outFile}"

    # Write the base64 encoded encrypted data to the output file
    writeFile(outFile, encodedCrypted)
  except Exception as e:
    echo "Failed to process file: ", e.msg

# Entry point
when isMainModule:
  processEncryption()